# 数据类型

## 变量名

- 只能用字母、数字或下划线
- 第一个字符不能是数字
- 大小写敏感
- 不能用C++关键字
- 以双下划线开头或以下划线和大写字母开头的名称是保留名称，以一个下划线开头的被用作全局标识符
- 对长度无限制

## 整型short、int、long、long long
- short至少16位
- int至少和short一样长
- long至少32位，且至少和int一样长
- long long至少64位，且至少和long一样长

| 数据类型           | 占用空间    | 取值范围                                                     |
| ------------------ | ----------- | ------------------------------------------------------------ |
| char               | 1byte,8bit  | $-128$~$127$                                                 |
| int                | 4byte,32bit | $-2^{31}$~$2^{31}$-$1$，约绝对值不超过$2.1\times10^9$的整数  |
| unsigned int       | 4byte,32bit | $0$~$2^{32}$-$1$，约不超过$4.2\times10^9$的非负整数          |
| long long          | 8byte,64bit | $-2^{63}$~$2^{63}$-$1$，约绝对值不超过$9.2\times10^{18}$的整数 |
| unsigned long long | 8byte,64bit | $0$~$2^{64}-1$，约不超过$1.8\times10^{19}$的非负整数         |
| float              | 4byte,32bit | 约指数绝对值不超过$37$，$6$位有效数字                        |
| double             | 8byte,64bit | 约指数绝对值不超过$307$，$15$位有效数字                      |

## sizeof运算符 和 头文件climits
对类型名使用`sizeof`运算符时，类型名应扩上括号。但对变量不用加括号。

头文件`climits`定义了符号常量来表示类型的限制。如前所说，`INT_MAX`表示类型`int`能够存储的最大的值。
| 符号常量 | 表示 |
| ------- | ---- |
| CHAR_BIT | char的位数 |
| CHAR_MAX | char的最大值 |
| CHAR_MIN | char的最小值 |
| SCHAR_MAX | signed char的最大值 |
| SCHAR_MIN | signed char的最小值 |
| UCHAR_MAX | unsigned char的最大值 |
| SHRT_MAX | short的最大值 |
| SHRT_MIN | short的最小值 |
| USHRT_MAX | unsigned short的最大值 |
| INT_MAX | int的最大值 |
| INT_MIN | int的最小值 |
| UINT_MAX | unsigned int的最大值 |
| LONG_MAX | long int的最大值 |
| LONG_MIN | long int的最小值 |
| ULONG_MAX | unsigned long的最大值 |
| LLONG_MAX | long long的最大值 |
| LLONG_MIN | long long的最小值 |
| ULLONG_MAX | unsigned long long的最大值 |

## 符号常量——预处理器方式
`climits`文件中包含与下面类似的语句行
```C++
#define INT_MAX 32767
```
> 在C++编译过程中，首先将源代码传递给预处理器，在这里，`define`和`#include`一样，也是一个预处理器编译指令。该编译指令告诉预处理器，在程序中查找INT_MAX，将所有的INT_MAX都替换成32767。因此，`define`编译指令的工作方式和文本编辑器或字处理器中的全局搜索并替换命令相似。修改后的程序将在完成这些替换后被编译。预处理器查找独立的标记（单独的单词），跳过嵌入的单词。也就是说，预处理器不会讲`PINT_MAXIM`替换为`P32767IM`。也可以使用`#define`来定义自己的符号常量。然而，`#define`编译指令时C语言遗留下来的。C++有一种更好的创建符号常量的方法（使用关键字`const`）。然而，有些头文件，尤其是哪些被设计成可用于C和C++种的头文件，则必须使用`#define`

## 初始化
```C++
int owls = 101; // C风格
int wrens(432); // C++特有的
```
还有一种C++11的初始化方式，这种方式用于数组和结构，但在C++98种，也可以用于单值变量。
```C++
int hamburgers = {24};
```
将大括号初始化器用于单值变量的情形还不多，但C++11标准使得这种情形更多了。首先，采用这种方式时，可以用等号，也可以不用。
```C++
int enum{7};
int rheas = {12};
```
其次，大括号内可以不包含任何东西，这种情况下，变量将会被初始化为零
```C++
int rocs = {};
int psychics{};
```

## 无符号类型
非负的数，正数范围会扩大两倍，只要在前面用`unsigned`修饰就行。

## 选择整数类型
大于16位用long，大于32位用long long，如果数组很大用short，如果只要8位就用char。

## 整型字面量（常量）
C++能用三种不同的计数方式来数学整数：基数为10，基数为8（老式UNIX版本），基数为16（硬件黑客的最爱）。

尽管整型字面值可以存储在带符号数据类型中，**但严格来说，十进制字面值不会是负数。**如果我们使用了一个形如－42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

C++使用前一（两）位来标识数字常量的基数。如果第一位为1~9，则基数为10（十进制）；因此`93`是以10为基数的。如果第一位是0，第二位为1~7，则基数为8（八进制）；因此`042`的基数是8，它相当于十进制数34。如果前两位为0x或0X，则基数为16（十六进制）；因此`0x42`为16进制数，相当于10进制数66。对于十六进制数，字符a~f和A~F表示了十六进制位，相对于10~15。

`cout`默认输出10进制数，计算机里存储这些数默认用的2进制。

可以用控制符`dec`、`hex`、`oct`分别用于指示`cout`以十进制、十六进制和八进制格式显示整数。
```C++
cout << 111 << endl << hex << 111 << endl << oct << 111;
```

## 常量的类型
```C++
cout << 1492;
```
程序会把1492存储成什么类型呢。答案是除非有理由存储为其他类型（比如使用特定**后缀**来表示特定的类型，或者值太大，不能存储为int），否则C++将整型常量存储为int类型。
### 常量后缀
| 后缀 | 类型 |
| ---- | --- |
| l、L | long |
| u、U | unsigned int |
| ul、lu、uL | unsigned long |
| ll、LL |long long|
| uLL |unsigned long long|

## 字符

### char类型：字符和小整数

char也是一种整型类型，它占用1个字节。

在cin和cout中，cin和cout会自动实现ASCII码和字符的转换。比如cin了"M"，存储在char变量中的不是"M"，而是ASCII码77。然而cout时不会输出77，而是M，这是因为cin和cout实现了自动转换。

对于char类型的字面量，应该用单引号括起。

```C++
char ch;
cin >> ch;
```

如果输入5并按回车键，将读取字符“5”，并将其对于的字符编码（ASCII编码53）存储到变量ch中。

```C++
int n;
cin >> n;
```

如果也输入5并按回车键，将读取字符“5”，将其转换为相应的数字值5，并存储到变量n中。

### 字符常量

#### 转义字符

```C++
#include <iostream>
int main()
{
    using namespace std;
    cout << "\aOperation \"HyperHype\" is now activated!\n";
    cout << "Enter your agent code:________\b\b\b\b\b\b\b\b";
    long code;
    cin >> code;
    cout << "\aYou entered " << code << "...\n";
    cout << "\aCode verified!Proceed with Plan z3!\n";
    return 0;
}
```

#### 通用字符名

C++实现支持一个基本的源字符集，即可以用来编写源代码的字符集。还有一个基本的执行字符集，它包括程序执行期间可以处理的字符。C++标准还允许实现提供扩展源字符集和扩展执行字符集。另外，那些被作为字母的额外字符也可以用作标识符名称中。

通用字符名的用法类似于转义序列。通用字符名可以以`\u`或`\U`打头。`\u`后面是4个十六进制位，`\U`后面则是8个十六进制位。这些位表示的是字符的ISO 10646码点。

> Unicode给每个字符指定了一个编号——码点。Unicode码点通常类似于下面这样：U-222B。

### signed char 和 unsigned char

char在默认情况下既不是无符号也不是有符号的，这由C++实现来决定。如果char有某种特定的行为对您来说非常重要，可以显式地将类型设置为signed char或unsigned char：

如果将char用作数值类型，则有无符号差异非常重要。unsigned char类型的表示范围通常为0~255，而signed char的表示范围为-128~127。但是如果存储的是ASCII码，那随便，有没有符号都可以。

### wchar_t

程序处理的字符集可能无法用一个8位的字节表示。对这种情况，C++的处理方式有两种。首先，如果大型字符集是实现的基本字符集，则编译器厂商可以将char定义为一个16位的字节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型`wchar_t`（宽字符类型）可以表示扩展字符集。`wchar_t`类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。对底层类型的选择取决于实现。

cin和cout将输入和输出看作是char流，因此不适用于来处理`wchar_t`类型。`iostream`头文件的最新版本提供了作用相似的工具——`wcin`和`wcout`，可以用于处理`wchar_t`流。另外，可以通过加上前缀**L**来指示宽字符常量和宽字符串。

如

```C++
wchar_t bob = L'P';
wcout << L"tall" << endl;
```

### C++11新增的类型：char16_t和char32_t

因为`wchar_t`的长度和符号特征随实现而异。因此C++11新增了类型char16_t和char32_t，两者都是无符号的，但前者是16位的，后者是32位。C++11使用前缀**u**和**U**来分别表示char16_t和char32_t的字符常量以及字符串常量。

## bool类型

任何非零值解释为`true`，零值解释为`false`。`true`转换为1，`false`转换为0。

## const限定符

创建常量的通用格式如下：

```C++
const type_name = value;
```

使用const和#define的区别。首先，const能指定类型。其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中。最后，可以将const用于更加复杂的类型，如数组和结构。

## 浮点数

使用浮点类型可以表示诸如2.5、3.14159和12332.32这样的数字，即带小数部分的数字。计算机将这样的值分为两部分存储，一部分表示值，另一部分用于对值进行放大或缩小。缩放因子的作用是移动小数点的位置，术语浮点因此得名。

### 书写浮点数

C++有两种书写浮点数的方式。第一种是使用常用的标准小数点表示法。

第二种表示浮点值的方法叫作**E**表示法，其外观是像这样的：3.45E6，这指的是3.45于1000000相乘的结果：E6指的是10的6次方，即1后面6个0.因此，3.45E6表示的是3450000，6被称为指数，3.45被称为尾数。下面是一些例子：

- 2.52e+8 // can use e or E, + is optional
- 8.33E-4
- 7E5 // same as 7.0E5

E表示法最适合于非常大的数和非常小的数。

> d.dddE+n指的是将小数点向右移n位，而d.dddE-n指的是将小数点向左移n位。

### 浮点类型

C++有3种浮点类型：float，double和long double。这些类型是按它们可以表示的有效位数和允许的指数最小范围来描述的。有效位是数字中有意义的位。

事实上，C和C++对于位数（存储浮点数所需位数）的要求是，float至少32位，double至少48位，且不少于float，long double至少和double一样多。这三种类型的有效位数可以一样多。然而，通常，float为32位，double为64位，long double为80、96或128位。另外，这3种类型的指数范围至少是-37到37。而float的尾数的有效数位为7位，double是15位。

在如下代码：

```C++
#include <iostream>
int main()
{
    using namespace std;
    cout.setf(ios_base::fixed,ios_base::floatfield); // fixed-point
    float tub = 10.0 / 3.0;
    double mint = 10.0 / 3.0;
    const float million = 1.0e6;

    cout << "tub = " << tub;
    cout << ", a million tubs = " << million * tub;
    cout << ",\nand ten million tubs = " << 10 * million * tub << endl;

    cout << "mint = " << mint << " and a million mints = ";
    cout << million * mint << endl;
}
```

输出结果为：

```
tub = 3.333333, a million tubs = 3333333.250000,
and ten million tubs = 33333332.000000
mint = 3.333333 and a million mints = 3333333.333333
```

这说明系统保证float至少有6位有效位。而double至少有15位有效位。

### 浮点常量

默认情况下，浮点常量都属于是double类型。如果希望常量为float类型，可以使用**f**和**F**后缀。对于long double类型，可使用**l**和**L**类型。

## 将类型分类

符号整型：signed char、short、int和long

无符号整型：上者的无符号版本

整型：long long、bool、char、wchar_t、符号整型、无符号整型

C++11新增：char16_t、char32_t

浮点型：float、double、long double

# 运算符

## 算术运算符

`+-*/%`

其中`/`在两个操作符都是整型时，为整除

`%`运算符只能用于整型，其中一个为负数的话，结果的符号满足如下规则：`(a/b)*b + a%b = a`

## 运算符优先级和结合性

对于有多个运算符的表达式，比如`3 + 4 * 5`，操作数`4`的两边有两个运算符，C++使用优先级规则来决定首先使用哪个运算符。算术运算符遵循通常的代数优先级，先乘除，后加减。当然也可以使用括号来执行自己定义的优先级。

有时，优先级列表并不够用，比如`120 / 4 * 5`，操作数`4`位于两个运算符中间，优先级本身不能确定是先计算`120 / 4`还是先计算`4 * 5`。当两个运算符优先级相同时，C++将看操作数的结合性是从左到右还是从右到左。如果是从左到右，就先对下操作数运用左侧的运算符。

注意，只有两个运算符被用于同一个操作数时，优先级和结合性规则才有效。如`20 * 5 + 24 * 6`，先算左边的乘法还是先算右边的乘法，是由实现决定的。

### 运算符重载

可以看到，对于`/`运算符，当操作数为整数于浮点数时，意义是不同的，这个就叫运算符的重载，是一个重要的OOP属性。

## 类型转换

C++有11种整型与3种浮点类型。C++将自动执行很多类型转换：

- 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换。
- 表达式中包含不同的类型时，C++将对值进行转换
- 将参数传递给函数时，C++将对值进行转换。

### 初始化和赋值进行的转换

C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将被转换为接收变量的类型。例如，假设`so_long`的类型为`long`，`thirty`的类型为`short`，而程序中包含这样的语句：

```C++
so_long = thirty
```

则进行赋值时，程序将`thirty`的值（通常是16位）扩展为long值（通常为32位）。扩展后将得到一个新值，这个值被存储在`so_long`中，而`thirty`的内容不变。

将一个值赋给取值范围更大的类型通常不会导致什么问题。然而，将一个很大的long值（如211222333）赋给float变量将降低精度，因为float只会存储6位有效数字，因此这个值将被四舍五入位2.11122E9。

初始化赋值允许**缩窄**，但可能会引发未定义行为，具体看编译器的实现。

### 以{}方式初始化进行的转换（C++11）

C++11将使用大括号的初始化称为列表初始化，因为这种初始化常用于给复杂的数据类型提供值列表。它对类型转换的要求更严格，它不允许**缩窄**。如下代码：

```C++
const int code = 66;
int x = 66;
char c1 {31325}; // 不允许
char c2 = {66};
char c3 {code};
char c4 = {x}; // 不允许
x = 31325;
char c5 = x;
```

### 表达式中的转换

C++将执行两种自动转换：首先，一些类型在出现时便会被自动转换；其次，有些类型在与其他类型同时出现在表达式中将被转换。

先看自动转换。在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。确切地说，true被转换为1，false被转换为0。这些转换被称为**整型提升**。看如下代码：

```C++
short chickens = 20;
short ducks = 35;
short fowl = chickens + ducks;
```

在执行第三行代码的时候，C++程序取得chickens和ducks的值，并将它们转换为int。然后，程序再将结果转换为short。通常将int选择为计算机最自然的类型，这意味着计算机使用这种类型时，运算速度可能最快。

还有其他的**整型提升**：如果short比int短，则unsigned short类型将被转换为int；如果两种类型的长度相同，则unsigned short将被转换为unsigned int。

同样，wchar_t将被提升为下列类型中第一个宽度足够存储wchar_t取值范围的类型：int、unsigned int、long、unsigned long。

将不同类型进行算术运算时，也会进行一些转换。例如将int和float相加。当运算涉及两种类型时，较小的类型将被转换为较大的类型。总之，编译器通过**校验表**来确定在算术表达式中执行的转换。下面是C++11版本的校验表，编译器将依次查询该列表。

（1）如果有一个操作数的类型时long double，则将另一个操作数转换为long double。

（2）否则，如果有一个操作数的类型是double，则将另一个操作数转换为double。

（3）否则，如果有一个操作数的类型是float，则将另一个操作数转换为float。

（4）否则，说明操作数都是整型，因此执行**整型提升**。

（5）在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型。

（6）如果一个操作数为有符号，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型。（注意，此转换不会影响结果，不会损失负号，见下例）

```C++
#include<iostream>
using namespace std;
int main(){
    unsigned long long b = 99uLL;
    long long c = -100LL;
    long long a = b + c;
    cout << a;
    return 0;
}
```

解释，首先`-100LL`和`99uLL`都不需要整型提升，也就是不符合前5条，它符合第6条。显然`uLL`的级别比`LL`级别高，于是把`-100LL`转换为`18446744073709551516uLL`，再进行相加，得到`18446744073709551615uLL`，再转换为`-1LL`。至于其中的运算，就涉及到二进制位的进位与溢出了。https://www.cnblogs.com/stonehat/archive/2011/10/14/2212141.html

（7）否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型。

（8）否则，将两个操作数都转换为有符号类型的无符号版本。

**整形级别**：有符号整型按级别从高到低依次为long long、long、int、short和signed char。无符号整型的排列顺序与有符号整型相同。类型char、signed char和unsigned char的级别相同。类型bool的级别最低。wchar_t、char16_t和char32_t的级别与其底层类型相同。

### 传递参数时的转换

传递参数时的类型转换通常由C++函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对char和short类型（signed和unsigned）应用整型提升。另外，为保持与传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double。

### 强制类型转换

C++还允许通过强制类型转换机制显式地进行类型转换。强制类型转换的格式有两种。例如，为将存储在变量thorn中的int值转换为long类型，可以使用下述表达式中的一种：

```C++
(long) thorn
long (thorn)
```

强制类型转换不会修改thorn变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值。



强制转换的通用格式如下：

```C++
(typename) value
typename (value)
```

第一种格式来自C语言，第二种格式是纯粹的C++。新格式的想法是，要让强制类型转换就像函数调用。

还有四种强制类型转换运算符。

```C++
static_cast<long> (thorn)
```

```C++
static_cast<typename> (value)
```

## C++11中的auto声明

auto可以自动推断类型。如：

``` C++
std::vector<double> scores;
std::vector<double>::iterator pv = scoress.begin();
```

就可以写为：

```C++
std::vector<double> scores;
auto pv = scores.begin();
```

