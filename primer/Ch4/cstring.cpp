#include<iostream>
int main(){
    char dog[8] = {'b', 'e', 'a', 'u', 'x', ' ', 'I', 'I'}; // not a string
    char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'}; // a string
// both arrays are char array, but only the 2nd array is a string. The NULL character is essential for C-style strings.
    char bird[11] = "Mr. Cheeps"; // this is a string constant, or string literal. the \0 is understood
    char fish[] = "Bubbles"; // let the compiler count

// string input
    using namespace std;
    const int ArSize = 20;
    char name[ArSize];
    char dessert[ArSize];
    cout << "Enter name:\n";
    cin >> name;
    cout << "Enter dessert:\n";
    cin >> dessert;
    cout << "name: " << name << "\ndessert: " << dessert << endl;
    /*
Enter name:
Wang fang
Enter dessert:
name: Wang
dessert: fang
    */
   // cin use white space(space, tab, newline) to determine where a string ends. so Wang fang is separated into two strings named Wang and fang.
   // cin takes Wang as the first string and puts it in the name array. This leaves fang in the input queue.
   // when cin searches the input queue for the dessert, it finds fang, so cin reads fang and puts it in the dessert array.

// read a single line as a string: getline() and get()
    // getline() will discard the line break, while get() leave it in the input queue.
    // getline(array_name, character_nums_include_null_character)
    cin.get();
    cout << "Enter name:\n";
    cin.getline(name,ArSize);
    cout << "Enter dessert\n";
    cin.getline(dessert,ArSize);
    cout << "name: " << name << "\ndessert: " << dessert << endl;;
    // get(array_name,ArSize)
    cout << "Enter name:\n";
    cin.get(name,ArSize);
    cout << "Enter dessert\n";
    cin.get(dessert,ArSize);
    cout << "name: " << name << "\ndessert: " << dessert << endl;
    // get() can read the next single character even the line break
    cin.get(name,ArSize).get(); // concatenate member functions
    // cin.get(name,ArSize) return a cin object.
    cin.getline(name,ArSize).getline(dessert,ArSize);

    // blank line and over input
    // will set failbit. can use cin.clear() to restore input

// input mixture of string and num
    int year;
    char address[80];
    cin >> year;
    cin.getline(address, 80);
    // user doesn't have the chance to input address. the problem is, when cin read the year, leave the newline character generated by the carriage return key in the input queue.
    // After cin.getline() read the newline character, it will consider it a blank line and assign an empty string to the address array.
    // to fix it
    cin.get(); // discard the newline character
    (cin >> year).get(); // the same;
}